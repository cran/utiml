<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Adriano Rivolli" />

<meta name="date" content="2020-02-06" />

<title>utiml: Utilities for multi-label learning</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' || rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#header {
text-align: center;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">utiml: Utilities for multi-label learning</h1>
<h4 class="author">Adriano Rivolli</h4>
<h4 class="date">2020-02-06</h4>



<p><strong>Version:</strong> 0.1.5</p>
<p>The utiml package is a framework to support multi-label processing, like Mulan on Weka. It is simple to use and extend. This tutorial explain the main topics related with the utiml package. More details and examples are available on <a href="https://github.com/rivolli/utiml">utiml repository</a>.</p>
<div id="introduction" class="section level2">
<h2>1. Introduction</h2>
<p>The general prupose of <strong>utiml</strong> is be an alternative to processing multi-label in R. The main methods available on this package are organized in the groups:</p>
<ul>
<li>Classification methods</li>
<li>Evaluation methods</li>
<li>Pre-process utilities</li>
<li>Sampling methods</li>
<li>Threshold methods</li>
</ul>
<p>The <strong>utiml</strong> package needs of the <a href="https://CRAN.R-project.org/package=mldr">mldr</a> package to handle multi-label datasets. It will be installed together with the <strong>utiml</strong><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<p>The installation process is similar to other packages available on CRAN:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">install.packages</span>(<span class="st">&quot;utiml&quot;</span>)</a></code></pre></div>
<p>After installed, you can now load the <strong>utiml</strong> package (The mldr package will be also loaded):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">library</span>(<span class="st">&quot;utiml&quot;</span>)</a></code></pre></div>
<pre><code>## Loading required package: mldr</code></pre>
<pre><code>## Loading required package: parallel</code></pre>
<pre><code>## Loading required package: ROCR</code></pre>
<pre><code>## Loading required package: gplots</code></pre>
<pre><code>## 
## Attaching package: 'gplots'</code></pre>
<pre><code>## The following object is masked from 'package:stats':
## 
##     lowess</code></pre>
<p>The <strong>utiml</strong> brings two multi-label datasets. A synthetic toy dataset called <code>toyml</code> and a real world dataset called <code>foodtruck</code>. To understand how to load your own dataset, we suggest the read of <a href="https://CRAN.R-project.org/package=mldr">mldr</a> documentation. The <code>toyml</code> contains 100 instances, 10 features and 5 labels, its prupose is to be used for small tests and examples.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">head</span>(toyml)</a></code></pre></div>
<pre><code>##        att1      att2      att3      att4     att5      att6      att7
## 1 -0.150258  0.000461  0.237302  0.004333 0.086273  0.611953 -0.040632
## 2  0.219093  0.023877  0.038309 -0.041287 0.013978  0.277978  0.147673
## 3  0.137491  0.042125  0.011613  0.066545 0.388947 -0.312591 -0.163133
## 4 -0.318716 -0.054081  0.005198  0.085436 0.660657  0.011783  0.096005
## 5  0.004815  0.659007  0.023343 -0.135839 0.063470 -0.207688  0.091519
## 6  0.336280 -0.140629 -0.032099 -0.365930 0.004982  0.124665 -0.133950
##       iatt8     iatt9    ratt10 y1 y2 y3 y4 y5
## 1 -0.215861  0.447483  0.611953  1  1  0  1  0
## 2 -0.592199 -0.164926  0.277978  1  1  0  1  0
## 3 -0.426994 -0.564884 -0.312591  1  1  0  1  0
## 4 -0.526278  0.505936  0.011783  1  1  0  0  1
## 5  0.170262  0.389038 -0.207688  1  1  0  0  0
## 6  0.652938  0.961077  0.124665  1  1  0  0  0</code></pre>
<p>The <code>foodtruck</code> contains different types of cousines to be predicted from user preferences and habits. The dataset has 12 labels:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" data-line-number="1">foodtruck<span class="op">$</span>labels</a></code></pre></div>
<pre><code>##                 index count       freq     IRLbl   SCUMBLE SCUMBLE.CV
## street_food        22   295 0.72481572  1.000000 0.1249889  1.0276904
## gourmet            23   120 0.29484029  2.458333 0.1396873  0.7994104
## italian_food       24    43 0.10565111  6.860465 0.2059097  0.4101859
## brazilian_food     25    72 0.17690418  4.097222 0.1463292  0.7305315
## mexican_food       26    41 0.10073710  7.195122 0.2491880  0.2759161
## chinese_food       27    16 0.03931204 18.437500 0.2831969  0.3981316
## japanese_food      28    36 0.08845209  8.194444 0.2113363  0.5936371
## arabic_food        29    25 0.06142506 11.800000 0.2840999  0.3441985
## snacks             30    67 0.16461916  4.402985 0.1526898  0.5780729
## healthy_food       31    33 0.08108108  8.939394 0.2138170  0.5414302
## fitness_food       32    30 0.07371007  9.833333 0.2268195  0.5120827
## sweets_desserts    33   154 0.37837838  1.915584 0.1730439  0.5959228</code></pre>
<p>In the following section, an overview of how to conduct a multi-label experiment are explained. Next, we explores each group of methods and its particularity.</p>
</div>
<div id="overview" class="section level2">
<h2>2. Overview</h2>
<p>After load the multi-label dataset some data processing may be necessary. The pre-processing methods are utilities that manipulate the <code>mldr</code> datasets. Suppose that we want to normalize the attributes values (between 0 and 1), we can do:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" data-line-number="1">mytoy &lt;-<span class="st"> </span><span class="kw">normalize_mldata</span>(toyml)</a></code></pre></div>
<p>Next, we want to stratification the dataset in two partitions (train and test), containing 65% and 35% of instances respectively, then we can do:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" data-line-number="1">ds &lt;-<span class="st"> </span><span class="kw">create_holdout_partition</span>(mytoy, <span class="kw">c</span>(<span class="dt">train=</span><span class="fl">0.65</span>, <span class="dt">test=</span><span class="fl">0.35</span>), <span class="st">&quot;iterative&quot;</span>)</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="kw">names</span>(ds)</a></code></pre></div>
<pre><code>## [1] &quot;train&quot; &quot;test&quot;</code></pre>
<p>Now, the <code>ds</code> object has two elements <code>ds$train</code> and <code>ds$test</code>, where the first will be used to create a model and the second to test the model. For example, using the <em>Binary Relevance</em> multi-label method with the base algorithm <em>Random Forest</em><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>, we can do:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" data-line-number="1">brmodel &lt;-<span class="st"> </span><span class="kw">br</span>(ds<span class="op">$</span>train, <span class="st">&quot;RF&quot;</span>, <span class="dt">seed=</span><span class="dv">123</span>)</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">prediction &lt;-<span class="st"> </span><span class="kw">predict</span>(brmodel, ds<span class="op">$</span>test)</a></code></pre></div>
<p>The <code>prediction</code> is an object of class <code>mlresult</code> that contains the probability (also called confidence or score) and the bipartitions values:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">head</span>(<span class="kw">as.bipartition</span>(prediction))</a></code></pre></div>
<pre><code>##    y1 y2 y3 y4 y5
## 8   0  1  0  1  0
## 10  1  1  0  1  0
## 12  0  1  0  1  0
## 14  0  1  0  1  0
## 18  0  1  0  1  0
## 19  0  1  0  1  0</code></pre>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">head</span>(<span class="kw">as.probability</span>(prediction))</a></code></pre></div>
<pre><code>##       y1    y2    y3    y4    y5
## 8  0.216 0.946 0.056 0.896 0.228
## 10 0.560 0.950 0.018 0.682 0.084
## 12 0.184 0.924 0.062 0.722 0.232
## 14 0.374 0.874 0.032 0.808 0.280
## 18 0.260 0.844 0.442 0.608 0.278
## 19 0.110 0.844 0.288 0.534 0.102</code></pre>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">head</span>(<span class="kw">as.ranking</span>(prediction))</a></code></pre></div>
<pre><code>##    y1 y2 y3 y4 y5
## 8   4  1  5  2  3
## 10  3  1  5  2  4
## 12  4  1  5  2  3
## 14  3  1  5  2  4
## 18  5  1  3  2  4
## 19  4  1  3  2  5</code></pre>
<p>A threshold strategy can be applied:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb23-1" data-line-number="1">newpred &lt;-<span class="st"> </span><span class="kw">rcut_threshold</span>(prediction, <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="kw">head</span>(newpred)</a></code></pre></div>
<pre><code>##    y1 y2 y3 y4 y5
## 8   0  1  0  1  0
## 10  0  1  0  1  0
## 12  0  1  0  1  0
## 14  0  1  0  1  0
## 18  0  1  0  1  0
## 19  0  1  0  1  0</code></pre>
<p>Now we can evaluate the models and compare if the use of the MCUT threshold improved the results:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb25-1" data-line-number="1">result &lt;-<span class="st"> </span><span class="kw">multilabel_evaluate</span>(ds<span class="op">$</span>tes, prediction, <span class="st">&quot;bipartition&quot;</span>)</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">thresres &lt;-<span class="st"> </span><span class="kw">multilabel_evaluate</span>(ds<span class="op">$</span>tes, newpred, <span class="st">&quot;bipartition&quot;</span>)</a>
<a class="sourceLine" id="cb25-3" data-line-number="3"></a>
<a class="sourceLine" id="cb25-4" data-line-number="4"><span class="kw">round</span>(<span class="kw">cbind</span>(<span class="dt">Default=</span>result, <span class="dt">RCUT=</span>thresres), <span class="dv">3</span>)</a></code></pre></div>
<pre><code>##                 Default  RCUT
## F1                0.710 0.732
## accuracy          0.581 0.600
## hamming-loss      0.211 0.200
## macro-AUC         0.578 0.578
## macro-F1          0.496 0.448
## macro-precision   0.688 0.592
## macro-recall      0.480 0.457
## micro-AUC         0.819 0.819
## micro-F1          0.730 0.745
## micro-precision   0.714 0.729
## micro-recall      0.746 0.761
## precision         0.719 0.729
## recall            0.790 0.824
## subset-accuracy   0.143 0.143</code></pre>
<p>Details of the labels evaluation can be obtained using:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb27-1" data-line-number="1">result &lt;-<span class="st"> </span><span class="kw">multilabel_evaluate</span>(ds<span class="op">$</span>tes, prediction, <span class="st">&quot;bipartition&quot;</span>, <span class="dt">labels=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">result<span class="op">$</span>labels</a></code></pre></div>
<pre><code>##          AUC        F1  accuracy    balacc precision    recall TP TN FP FN
## y1 0.7466667 0.2857143 0.8571429 0.5833333 0.5000000 0.2000000  1 29  1  4
## y2 0.6597222 0.8709677 0.7714286 0.5000000 0.7714286 1.0000000 27  0  8  0
## y3 0.6091954 0.2500000 0.8285714 0.5660920 0.5000000 0.1666667  1 28  1  5
## y4 0.3200758 0.7407407 0.6000000 0.4621212 0.6666667 0.8333333 20  1 10  4
## y5 0.5533333 0.3333333 0.8857143 0.6000000 1.0000000 0.2000000  1 30  0  4</code></pre>
</div>
<div id="pre-processing" class="section level2">
<h2>3. Pre-processing</h2>
<p>The pre-processing methods were developed to facilitate some operations with the multi-label data. Each pre-processing method receives a mldr dataset and returns other mldr dataset. You can use them as needed.</p>
<p>Here, an overview of the pre-processing methods:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="co"># Fill sparse data</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2">mdata &lt;-<span class="st"> </span><span class="kw">fill_sparse_mldata</span>(toyml)</a>
<a class="sourceLine" id="cb29-3" data-line-number="3"></a>
<a class="sourceLine" id="cb29-4" data-line-number="4"><span class="co"># Remove unique attributes</span></a>
<a class="sourceLine" id="cb29-5" data-line-number="5">mdata &lt;-<span class="st"> </span><span class="kw">remove_unique_attributes</span>(toyml)</a>
<a class="sourceLine" id="cb29-6" data-line-number="6"></a>
<a class="sourceLine" id="cb29-7" data-line-number="7"><span class="co"># Remove the attributes &quot;iatt8&quot;, &quot;iatt9&quot; and &quot;ratt10&quot;</span></a>
<a class="sourceLine" id="cb29-8" data-line-number="8">mdata &lt;-<span class="st"> </span><span class="kw">remove_attributes</span>(toyml, <span class="kw">c</span>(<span class="st">&quot;iatt8&quot;</span>, <span class="st">&quot;iatt9&quot;</span>, <span class="st">&quot;ratt10&quot;</span>))</a>
<a class="sourceLine" id="cb29-9" data-line-number="9"></a>
<a class="sourceLine" id="cb29-10" data-line-number="10"><span class="co"># Remove labels with less than 10 positive or negative examples</span></a>
<a class="sourceLine" id="cb29-11" data-line-number="11">mdata &lt;-<span class="st"> </span><span class="kw">remove_skewness_labels</span>(toyml, <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb29-12" data-line-number="12"></a>
<a class="sourceLine" id="cb29-13" data-line-number="13"><span class="co"># Remove the labels &quot;y2&quot; and &quot;y3&quot;</span></a>
<a class="sourceLine" id="cb29-14" data-line-number="14">mdata &lt;-<span class="st"> </span><span class="kw">remove_labels</span>(toyml, <span class="kw">c</span>(<span class="st">&quot;y2&quot;</span>, <span class="st">&quot;y3&quot;</span>))</a>
<a class="sourceLine" id="cb29-15" data-line-number="15"></a>
<a class="sourceLine" id="cb29-16" data-line-number="16"><span class="co"># Remove the examples without any labels</span></a>
<a class="sourceLine" id="cb29-17" data-line-number="17">mdata &lt;-<span class="st"> </span><span class="kw">remove_unlabeled_instances</span>(toyml)</a>
<a class="sourceLine" id="cb29-18" data-line-number="18"></a>
<a class="sourceLine" id="cb29-19" data-line-number="19"><span class="co"># Replace nominal attributes</span></a>
<a class="sourceLine" id="cb29-20" data-line-number="20">mdata &lt;-<span class="st"> </span><span class="kw">replace_nominal_attributes</span>(toyml)</a>
<a class="sourceLine" id="cb29-21" data-line-number="21"></a>
<a class="sourceLine" id="cb29-22" data-line-number="22"><span class="co"># Normalize the predictive attributes between 0 and 1</span></a>
<a class="sourceLine" id="cb29-23" data-line-number="23">mdata &lt;-<span class="st"> </span><span class="kw">normalize_mldata</span>(mdata)</a></code></pre></div>
</div>
<div id="sampling" class="section level2">
<h2>4. Sampling</h2>
<div id="subsets" class="section level3">
<h3>4.1 Subsets</h3>
<p>If you want to create a specific or a random subset of a dataset, you can use the methods <code>create_subset</code> and <code>create_random_subset</code>, respectively. In the first case, you should specify which rows and optionally attributes, you want. In the second case, you just define the number of instances and optionally the number of attributes.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="co"># Create a subset of toyml dataset with the even instances and the first five attributes</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2">mdata &lt;-<span class="st"> </span><span class="kw">create_subset</span>(toyml, <span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">100</span>, <span class="dv">2</span>), <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>)</a>
<a class="sourceLine" id="cb30-3" data-line-number="3"></a>
<a class="sourceLine" id="cb30-4" data-line-number="4"><span class="co"># Create a subset of toyml dataset with the ten first instances and all attributes</span></a>
<a class="sourceLine" id="cb30-5" data-line-number="5">mdata &lt;-<span class="st"> </span><span class="kw">create_subset</span>(toyml, <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)</a>
<a class="sourceLine" id="cb30-6" data-line-number="6"></a>
<a class="sourceLine" id="cb30-7" data-line-number="7"><span class="co"># Create a random subset of toyml dataset with 30 instances and 6 attributes</span></a>
<a class="sourceLine" id="cb30-8" data-line-number="8">mdata &lt;-<span class="st"> </span><span class="kw">create_random_subset</span>(toyml, <span class="dv">30</span>, <span class="dv">6</span>)</a>
<a class="sourceLine" id="cb30-9" data-line-number="9"></a>
<a class="sourceLine" id="cb30-10" data-line-number="10"><span class="co"># Create a random subset of toyml dataset with 7 instances and all attributes</span></a>
<a class="sourceLine" id="cb30-11" data-line-number="11">mdata &lt;-<span class="st"> </span><span class="kw">create_random_subset</span>(toyml, <span class="dv">7</span>)</a></code></pre></div>
</div>
<div id="holdout" class="section level3">
<h3>4.2 Holdout</h3>
<p>To create two or more partitions of the dataset, we use the method <code>create_holdout_partition</code>. The first argument is a mldr dataset, the second is the size of partitions and the third is the partition method. The options are: <code>random</code>, <code>iterative</code> and <code>stratified</code>. The <code>iterative</code> is a stratification by label and the <code>stratified</code> is a stratification by labelset. The return of the method is a list with the names defined by the second parameter. See some examples:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="co"># Create two equal partitions using the 'iterative' method</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2">toy &lt;-<span class="st"> </span><span class="kw">create_holdout_partition</span>(toyml, <span class="kw">c</span>(<span class="dt">train=</span><span class="fl">0.5</span>, <span class="dt">test=</span><span class="fl">0.5</span>), <span class="st">&quot;iterative&quot;</span>)</a>
<a class="sourceLine" id="cb31-3" data-line-number="3"><span class="co">## toy$train and toy$test is a mldr object</span></a>
<a class="sourceLine" id="cb31-4" data-line-number="4"></a>
<a class="sourceLine" id="cb31-5" data-line-number="5"><span class="co"># Create three partitions using the 'random' method</span></a>
<a class="sourceLine" id="cb31-6" data-line-number="6">toy &lt;-<span class="st"> </span><span class="kw">create_holdout_partition</span>(toyml, <span class="kw">c</span>(<span class="dt">a=</span><span class="fl">0.4</span>, <span class="dt">b=</span><span class="fl">0.3</span>, <span class="dt">c=</span><span class="fl">0.3</span>))</a>
<a class="sourceLine" id="cb31-7" data-line-number="7"><span class="co">## Use toy$a, toy$b and toy$c</span></a>
<a class="sourceLine" id="cb31-8" data-line-number="8"></a>
<a class="sourceLine" id="cb31-9" data-line-number="9"><span class="co"># Create two partitions using the 'stratified' method</span></a>
<a class="sourceLine" id="cb31-10" data-line-number="10">toy &lt;-<span class="st"> </span><span class="kw">create_holdout_partition</span>(toyml, <span class="kw">c</span>(<span class="fl">0.6</span>, <span class="fl">0.4</span>), <span class="st">&quot;stratified&quot;</span>)</a>
<a class="sourceLine" id="cb31-11" data-line-number="11"><span class="co">## Use toy[[1]] and toy[[2]] </span></a></code></pre></div>
</div>
<div id="k-folds" class="section level3">
<h3>4.3 k-Folds</h3>
<p>The simplest way to run a k-fold cross validation is by using the method <code>cv</code>:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb32-1" data-line-number="1">results &lt;-<span class="st"> </span><span class="kw">cv</span>(foodtruck, br, <span class="dt">base.algorith=</span><span class="st">&quot;SVM&quot;</span>, <span class="dt">cv.folds=</span><span class="dv">5</span>, </a>
<a class="sourceLine" id="cb32-2" data-line-number="2">              <span class="dt">cv.sampling=</span><span class="st">&quot;stratified&quot;</span>, <span class="dt">cv.measures=</span><span class="st">&quot;example-based&quot;</span>, </a>
<a class="sourceLine" id="cb32-3" data-line-number="3">              <span class="dt">cv.seed=</span><span class="dv">123</span>)</a>
<a class="sourceLine" id="cb32-4" data-line-number="4"></a>
<a class="sourceLine" id="cb32-5" data-line-number="5"><span class="kw">round</span>(results, <span class="dv">4</span>)</a></code></pre></div>
<pre><code>##              F1        accuracy    hamming-loss       precision 
##          0.5186          0.4396          0.1517          0.7024 
##          recall subset-accuracy 
##          0.4796          0.2555</code></pre>
<p>To obtain detailed results of the folds, use the parameter <code>cv.results</code>, such that:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb34-1" data-line-number="1">results &lt;-<span class="st"> </span><span class="kw">cv</span>(toyml, <span class="st">&quot;rakel&quot;</span>, <span class="dt">base.algorith=</span><span class="st">&quot;RF&quot;</span>, <span class="dt">cv.folds=</span><span class="dv">10</span>, <span class="dt">cv.results=</span><span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb34-2" data-line-number="2">              <span class="dt">cv.sampling=</span><span class="st">&quot;random&quot;</span>, <span class="dt">cv.measures=</span><span class="st">&quot;example-based&quot;</span>)</a>
<a class="sourceLine" id="cb34-3" data-line-number="3"></a>
<a class="sourceLine" id="cb34-4" data-line-number="4"><span class="co">#Multi-label results</span></a>
<a class="sourceLine" id="cb34-5" data-line-number="5"><span class="kw">round</span>(results<span class="op">$</span>multilabel, <span class="dv">4</span>)</a></code></pre></div>
<pre><code>##           F1 accuracy hamming-loss precision recall subset-accuracy
##  [1,] 0.7367   0.6000         0.20    0.8000 0.7667             0.1
##  [2,] 0.7867   0.6833         0.18    0.8333 0.8167             0.3
##  [3,] 0.8533   0.7667         0.12    0.9000 0.8667             0.4
##  [4,] 0.5467   0.4000         0.30    0.6000 0.6000             0.0
##  [5,] 0.5333   0.4250         0.34    0.5333 0.6167             0.1
##  [6,] 0.6900   0.5500         0.24    0.7000 0.7500             0.1
##  [7,] 0.8533   0.7917         0.12    0.8500 0.9000             0.6
##  [8,] 0.7600   0.6500         0.22    0.8000 0.8000             0.3
##  [9,] 0.7767   0.6667         0.16    0.7667 0.8667             0.3
## [10,] 0.6533   0.5333         0.26    0.6833 0.7167             0.1</code></pre>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="co">#Labels results</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2"><span class="kw">round</span>(<span class="kw">sapply</span>(results<span class="op">$</span>labels, colMeans), <span class="dv">4</span>)</a></code></pre></div>
<pre><code>##            y1  y2   y3   y4   y5
## accuracy 0.81 0.8 0.81 0.69 0.82
## balacc    NaN NaN  NaN  NaN  NaN
## TP       0.10 7.7 0.30 6.50 0.00
## TN       8.00 0.3 7.80 0.40 8.20
## FP       0.30 1.9 0.30 2.70 0.10
## FN       1.60 0.1 1.60 0.40 1.70</code></pre>
<p>Finally, to manually run a k-fold cross validation, you can use the <code>create_kfold_partition</code>. The return of this method is an object of type <code>kFoldPartition</code> that will be used with the method <code>partition_fold</code> to create the datasets:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="co"># Create 3-fold object</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2">kfcv &lt;-<span class="st"> </span><span class="kw">create_kfold_partition</span>(toyml, <span class="dt">k=</span><span class="dv">3</span>, <span class="st">&quot;iterative&quot;</span>)</a>
<a class="sourceLine" id="cb38-3" data-line-number="3">result &lt;-<span class="st"> </span><span class="kw">lapply</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="cf">function</span> (k) {</a>
<a class="sourceLine" id="cb38-4" data-line-number="4">  toy &lt;-<span class="st"> </span><span class="kw">partition_fold</span>(kfcv, k)</a>
<a class="sourceLine" id="cb38-5" data-line-number="5">  model &lt;-<span class="st"> </span><span class="kw">br</span>(toy<span class="op">$</span>train, <span class="st">&quot;RF&quot;</span>)</a>
<a class="sourceLine" id="cb38-6" data-line-number="6">  <span class="kw">predict</span>(model, toy<span class="op">$</span>test)</a>
<a class="sourceLine" id="cb38-7" data-line-number="7">})</a>
<a class="sourceLine" id="cb38-8" data-line-number="8"></a>
<a class="sourceLine" id="cb38-9" data-line-number="9"><span class="co"># Create 5-fold object and use a validation set</span></a>
<a class="sourceLine" id="cb38-10" data-line-number="10">kfcv &lt;-<span class="st"> </span><span class="kw">create_kfold_partition</span>(toyml, <span class="dv">5</span>, <span class="st">&quot;stratified&quot;</span>)</a>
<a class="sourceLine" id="cb38-11" data-line-number="11">result &lt;-<span class="st"> </span><span class="kw">lapply</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="cf">function</span> (k) {</a>
<a class="sourceLine" id="cb38-12" data-line-number="12">  toy &lt;-<span class="st"> </span><span class="kw">partition_fold</span>(kfcv, k, <span class="dt">has.validation=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb38-13" data-line-number="13">  model &lt;-<span class="st"> </span><span class="kw">br</span>(toy<span class="op">$</span>train, <span class="st">&quot;RF&quot;</span>)</a>
<a class="sourceLine" id="cb38-14" data-line-number="14">  </a>
<a class="sourceLine" id="cb38-15" data-line-number="15">  <span class="kw">list</span>(</a>
<a class="sourceLine" id="cb38-16" data-line-number="16">    <span class="dt">validation =</span> <span class="kw">predict</span>(model, toy<span class="op">$</span>validation),</a>
<a class="sourceLine" id="cb38-17" data-line-number="17">    <span class="dt">test =</span> <span class="kw">predict</span>(model, toy<span class="op">$</span>test)</a>
<a class="sourceLine" id="cb38-18" data-line-number="18">  )</a>
<a class="sourceLine" id="cb38-19" data-line-number="19">})</a></code></pre></div>
</div>
</div>
<div id="classification-methods" class="section level2">
<h2>5. Classification Methods</h2>
<p>The multi-label classification is a supervised learning task that seeks to learn and predict one or more labels together. This task can be grouped in: problem transformation and algorithm adaptation. Next, we provide more details about the methods and their specifities.</p>
<div id="transformation-methods-and-base-algorihtms" class="section level3">
<h3>5.1 Transformation methods and Base Algorihtms</h3>
<p>The transformation methods require a base algorithm (binary or multi-class) and use their predictions to compose the multi-label result. In the <strong>utiml</strong> package there are some default base algorithms that are accepted.</p>
<p>Each base algorithm requires a specific package, you need to install manually it, because they are not installed together with <strong>utiml</strong>. The follow algorithm learners are supported:</p>
<table>
<thead>
<tr class="header">
<th align="left">Use</th>
<th align="left">Name</th>
<th align="left">Package</th>
<th align="left">Call</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">CART</td>
<td align="left">Classification and regression trees</td>
<td align="left">rpart</td>
<td align="left">rpart::rpart(…)</td>
</tr>
<tr class="even">
<td align="left">C5.0</td>
<td align="left">C5.0 Decision Trees and Rule-Based Models</td>
<td align="left">C50</td>
<td align="left">C50::C5.0(…)</td>
</tr>
<tr class="odd">
<td align="left">J48</td>
<td align="left">Java implementation of the C4.5</td>
<td align="left">RWeka and rJava</td>
<td align="left">RWeka::J48(…)</td>
</tr>
<tr class="even">
<td align="left">KNN</td>
<td align="left">K Nearest Neighbor</td>
<td align="left">kknn</td>
<td align="left">kknn::kknn(…)</td>
</tr>
<tr class="odd">
<td align="left">MAJORITY</td>
<td align="left">Majority class prediction</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr class="even">
<td align="left">NB</td>
<td align="left">Naive Bayes</td>
<td align="left">e1071</td>
<td align="left">e1071::naiveBayes(…)</td>
</tr>
<tr class="odd">
<td align="left">RANDOM</td>
<td align="left">Random prediction</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr class="even">
<td align="left">RF</td>
<td align="left">Random Forest</td>
<td align="left">randomForest</td>
<td align="left">randomForest::randomForest(…)</td>
</tr>
<tr class="odd">
<td align="left">SVM</td>
<td align="left">Support Vector Machine</td>
<td align="left">e1071</td>
<td align="left">e1071::svm(…)</td>
</tr>
</tbody>
</table>
<p>To realize a classification first it is necessary to create a multi-label model, the available methods are:</p>
<table>
<thead>
<tr class="header">
<th align="left">Method</th>
<th align="left">Name</th>
<th align="left">Approach</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">br</td>
<td align="left">Binary Relevance (BR)</td>
<td align="left">one-against-all</td>
</tr>
<tr class="even">
<td align="left">brplus</td>
<td align="left">BR+</td>
<td align="left">one-against-all; stacking</td>
</tr>
<tr class="odd">
<td align="left">cc</td>
<td align="left">Classifier Chains</td>
<td align="left">one-against-all; chaining</td>
</tr>
<tr class="even">
<td align="left">clr</td>
<td align="left">Calibrated Label Ranking (CLR)</td>
<td align="left">one-versus-one</td>
</tr>
<tr class="odd">
<td align="left">ctrl</td>
<td align="left">ConTRolled Label correlation exploitation (CTRL)</td>
<td align="left">one-against-all; ensemble</td>
</tr>
<tr class="even">
<td align="left">dbr</td>
<td align="left">Dependent Binary Relevance (DBR)</td>
<td align="left">one-against-all; stacking</td>
</tr>
<tr class="odd">
<td align="left">ebr</td>
<td align="left">Ensemble of Binary Relevance (EBR)</td>
<td align="left">one-against-all; ensemble</td>
</tr>
<tr class="even">
<td align="left">ecc</td>
<td align="left">Ensemble of Classifier Chains (ECC)</td>
<td align="left">one-against-all; ensemble</td>
</tr>
<tr class="odd">
<td align="left">eps</td>
<td align="left">Ensemble of Pruned Set (EPS)</td>
<td align="left">powerset</td>
</tr>
<tr class="even">
<td align="left">homer</td>
<td align="left">Hierarchy Of Multi-label classifiER (HOMER)</td>
<td align="left">hierarchy</td>
</tr>
<tr class="odd">
<td align="left">lift</td>
<td align="left">Learning with Label specIfic FeaTures (LIFT)</td>
<td align="left">one-against-all</td>
</tr>
<tr class="even">
<td align="left">lp</td>
<td align="left">Label Powerset (LP)</td>
<td align="left">powerset</td>
</tr>
<tr class="odd">
<td align="left">mbr</td>
<td align="left">Meta-Binary Relevance (MBR or 2BR)</td>
<td align="left">one-against-all; stacking</td>
</tr>
<tr class="even">
<td align="left">ns</td>
<td align="left">Nested Stacking (NS)</td>
<td align="left">one-against-all; chaining</td>
</tr>
<tr class="odd">
<td align="left">ppt</td>
<td align="left">Pruned Problem Transformation (PPT)</td>
<td align="left">powerset</td>
</tr>
<tr class="even">
<td align="left">prudent</td>
<td align="left">Pruned and Confident Stacking Approach (Prudent)</td>
<td align="left">one-against-all; stacking</td>
</tr>
<tr class="odd">
<td align="left">ps</td>
<td align="left">Pruned Set (PS)</td>
<td align="left">powerset</td>
</tr>
<tr class="even">
<td align="left">rakel</td>
<td align="left">Random k-labelsets (RAkEL)</td>
<td align="left">powerset</td>
</tr>
<tr class="odd">
<td align="left">rdbr</td>
<td align="left">Recursive Dependent Binary Relevance (RDBR)</td>
<td align="left">one-against-all; stacking</td>
</tr>
<tr class="even">
<td align="left">rpc</td>
<td align="left">Ranking by Pairwise Comparison (RPC)</td>
<td align="left">one-versus-one</td>
</tr>
</tbody>
</table>
<p>The first and second parameters of each multi-label method is always the same: The multi-label dataset and the base algorithm, respectively. However, they may have specific parameters, examples:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="co">#Classifier chain with a specific chain</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2">ccmodel &lt;-<span class="st"> </span><span class="kw">cc</span>(toyml, <span class="st">&quot;RF&quot;</span>, <span class="dt">chain =</span> <span class="kw">c</span>(<span class="st">&quot;y5&quot;</span>, <span class="st">&quot;y4&quot;</span>, <span class="st">&quot;y3&quot;</span>, <span class="st">&quot;y2&quot;</span>, <span class="st">&quot;y1&quot;</span>))</a>
<a class="sourceLine" id="cb39-3" data-line-number="3"></a>
<a class="sourceLine" id="cb39-4" data-line-number="4"><span class="co"># Ensemble with 5 models using 60% of sampling and 75% of attributes</span></a>
<a class="sourceLine" id="cb39-5" data-line-number="5">ebrmodel &lt;-<span class="st"> </span><span class="kw">ebr</span>(toyml, <span class="st">&quot;C5.0&quot;</span>, <span class="dt">m =</span> <span class="dv">5</span>, <span class="dt">subsample=</span><span class="fl">0.6</span>, <span class="dt">attr =</span> <span class="fl">0.75</span>)</a></code></pre></div>
<p>Beyond the parameters of each multi-label methods, you can define the parameters for the base algorithm, like this:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="co"># Specific parameters for SVM</span></a>
<a class="sourceLine" id="cb40-2" data-line-number="2">brmodel &lt;-<span class="st"> </span><span class="kw">br</span>(toyml, <span class="st">&quot;SVM&quot;</span>, <span class="dt">gamma =</span> <span class="fl">0.1</span>, <span class="dt">scale=</span><span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb40-3" data-line-number="3"></a>
<a class="sourceLine" id="cb40-4" data-line-number="4"><span class="co"># Specific parameters for KNN</span></a>
<a class="sourceLine" id="cb40-5" data-line-number="5">ccmodel &lt;-<span class="st"> </span><span class="kw">cc</span>(toyml, <span class="st">&quot;KNN&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;y5&quot;</span>, <span class="st">&quot;y4&quot;</span>, <span class="st">&quot;y3&quot;</span>, <span class="st">&quot;y2&quot;</span>, <span class="st">&quot;y1&quot;</span>), <span class="dt">k=</span><span class="dv">5</span>)</a>
<a class="sourceLine" id="cb40-6" data-line-number="6"></a>
<a class="sourceLine" id="cb40-7" data-line-number="7"><span class="co"># Specific parameters for Random Forest</span></a>
<a class="sourceLine" id="cb40-8" data-line-number="8">ebrmodel &lt;-<span class="st"> </span><span class="kw">ebr</span>(toyml, <span class="st">&quot;RF&quot;</span>, <span class="dv">5</span>, <span class="fl">0.6</span>, <span class="fl">0.75</span>, <span class="dt">proximity=</span><span class="ot">TRUE</span>, <span class="dt">ntree=</span><span class="dv">100</span>)</a></code></pre></div>
<p>After build the model, To predict new data use the <code>predict</code> method. Here, some predict methods require specific arguments and you can assign arguments for the base method too. For default, all base learner will predict the probability of prediciton, then do not use these parameters. Instead of, use the <code>probability</code> parameter defined by the multi-label prediction method.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="co"># Predict the BR model</span></a>
<a class="sourceLine" id="cb41-2" data-line-number="2">result &lt;-<span class="st"> </span><span class="kw">predict</span>(brmodel, toyml)</a>
<a class="sourceLine" id="cb41-3" data-line-number="3"></a>
<a class="sourceLine" id="cb41-4" data-line-number="4"><span class="co"># Specific parameters for KNN</span></a>
<a class="sourceLine" id="cb41-5" data-line-number="5">result &lt;-<span class="st"> </span><span class="kw">predict</span>(ccmodel, toyml, <span class="dt">kernel=</span><span class="st">&quot;triangular&quot;</span>, <span class="dt">probability =</span> <span class="ot">FALSE</span>)</a></code></pre></div>
<p>An object of type <code>mlresult</code> is the return of predict method. It always contains the bipartitions and the probabilities values. So you can use: <code>as.bipartition</code>, <code>as.probability</code> and <code>as.ranking</code> for specific values.</p>
</div>
<div id="algorithm-adapatation" class="section level3">
<h3>5.2 Algorithm adapatation</h3>
<p>Until now, only a single adaptation method is available the <code>mlknn</code>.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb42-1" data-line-number="1">model &lt;-<span class="st"> </span><span class="kw">mlknn</span>(toyml, <span class="dt">k=</span><span class="dv">3</span>)</a>
<a class="sourceLine" id="cb42-2" data-line-number="2">pred &lt;-<span class="st"> </span><span class="kw">predict</span>(model, toyml)</a></code></pre></div>
</div>
<div id="seed-and-multicores" class="section level3">
<h3>5.3 Seed and Multicores</h3>
<p>Almost all multi-label methods can run in parallel. The train and prediction methods receive a parameter called <code>cores</code> that specify the number of cores used to run the method. For some multi-label methods are not possible running in multi-core, then read the documentation of each method, for more details.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="co"># Running Binary Relevance method using 4 cores</span></a>
<a class="sourceLine" id="cb43-2" data-line-number="2">brmodel &lt;-<span class="st"> </span><span class="kw">br</span>(toyml, <span class="st">&quot;SVM&quot;</span>, <span class="dt">cores=</span><span class="dv">4</span>)</a>
<a class="sourceLine" id="cb43-3" data-line-number="3">prediction &lt;-<span class="st"> </span><span class="kw">predict</span>(brmodel, toyml, <span class="dt">cores=</span><span class="dv">4</span>)</a></code></pre></div>
<p>If you need of reproducibility, you can set a specific seed:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="co"># Running Binary Relevance method using 4 cores</span></a>
<a class="sourceLine" id="cb44-2" data-line-number="2">brmodel &lt;-<span class="st"> </span><span class="kw">br</span>(toyml, <span class="st">&quot;SVM&quot;</span>, <span class="dt">cores=</span><span class="dv">4</span>, <span class="dt">seed=</span><span class="dv">1984</span>)</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">prediction &lt;-<span class="st"> </span><span class="kw">predict</span>(brmodel, toyml, <span class="dt">seed=</span><span class="dv">1984</span>, <span class="dt">cores=</span><span class="dv">4</span>)</a></code></pre></div>
<p>The <code>cv</code> method also supports multicores:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb45-1" data-line-number="1">results &lt;-<span class="st"> </span><span class="kw">cv</span>(toyml, <span class="dt">method=</span><span class="st">&quot;ecc&quot;</span>, <span class="dt">base.algorith=</span><span class="st">&quot;RF&quot;</span>, <span class="dt">subsample =</span> <span class="fl">0.9</span>, <span class="dt">attr.space =</span> <span class="fl">0.9</span>, <span class="dt">cv.folds=</span><span class="dv">5</span>, <span class="dt">cv.cores=</span><span class="dv">4</span>)</a></code></pre></div>
</div>
</div>
<div id="thresholds" class="section level2">
<h2>6. Thresholds</h2>
<p>The threshold methods receive a <code>mlresult</code> object and return a new <code>mlresult</code>, except for <code>scut</code> that returns the threshold values. These methods, change mainly the bipartitions values using the probabilities values.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="co"># Use a fixed threshold for all labels </span></a>
<a class="sourceLine" id="cb46-2" data-line-number="2">newpred &lt;-<span class="st"> </span><span class="kw">fixed_threshold</span>(prediction, <span class="fl">0.4</span>)</a>
<a class="sourceLine" id="cb46-3" data-line-number="3"></a>
<a class="sourceLine" id="cb46-4" data-line-number="4"><span class="co"># Use a specific threshold for each label </span></a>
<a class="sourceLine" id="cb46-5" data-line-number="5">newpred &lt;-<span class="st"> </span><span class="kw">fixed_threshold</span>(prediction, <span class="kw">c</span>(<span class="fl">0.4</span>, <span class="fl">0.5</span>, <span class="fl">0.6</span>, <span class="fl">0.7</span>, <span class="fl">0.8</span>))</a>
<a class="sourceLine" id="cb46-6" data-line-number="6"></a>
<a class="sourceLine" id="cb46-7" data-line-number="7"><span class="co"># Use the MCut approch to define the threshold</span></a>
<a class="sourceLine" id="cb46-8" data-line-number="8">newpred &lt;-<span class="st"> </span><span class="kw">mcut_threshold</span>(prediction)</a>
<a class="sourceLine" id="cb46-9" data-line-number="9"></a>
<a class="sourceLine" id="cb46-10" data-line-number="10"><span class="co"># Use the PCut threshold</span></a>
<a class="sourceLine" id="cb46-11" data-line-number="11">newpred &lt;-<span class="st"> </span><span class="kw">pcut_threshold</span>(prediction, <span class="dt">ratio=</span><span class="fl">0.65</span>)</a>
<a class="sourceLine" id="cb46-12" data-line-number="12"></a>
<a class="sourceLine" id="cb46-13" data-line-number="13"><span class="co"># Use the RCut threshold</span></a>
<a class="sourceLine" id="cb46-14" data-line-number="14">newpred &lt;-<span class="st"> </span><span class="kw">rcut_threshold</span>(prediction, <span class="dt">k=</span><span class="dv">3</span>)</a>
<a class="sourceLine" id="cb46-15" data-line-number="15"></a>
<a class="sourceLine" id="cb46-16" data-line-number="16"><span class="co"># Choose the best threshold values based on a Mean Squared Error </span></a>
<a class="sourceLine" id="cb46-17" data-line-number="17">thresholds &lt;-<span class="st"> </span><span class="kw">scut_threshold</span>(prediction, toyml, <span class="dt">cores =</span> <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb46-18" data-line-number="18">newpred &lt;-<span class="st"> </span><span class="kw">fixed_threshold</span>(prediction, thresholds)</a>
<a class="sourceLine" id="cb46-19" data-line-number="19"></a>
<a class="sourceLine" id="cb46-20" data-line-number="20"><span class="co">#Predict only the labelsets present in the train data</span></a>
<a class="sourceLine" id="cb46-21" data-line-number="21">newpred &lt;-<span class="st"> </span><span class="kw">subset_correction</span>(prediction, toyml)</a></code></pre></div>
</div>
<div id="evaluation" class="section level2">
<h2>7. Evaluation</h2>
<p>To evaluate multi-label models you can use the method <code>multilabel_evaluate</code>. There are two ways of call this method:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb47-1" data-line-number="1">toy &lt;-<span class="st"> </span><span class="kw">create_holdout_partition</span>(toyml)</a>
<a class="sourceLine" id="cb47-2" data-line-number="2">brmodel &lt;-<span class="st"> </span><span class="kw">br</span>(toy<span class="op">$</span>train, <span class="st">&quot;SVM&quot;</span>)</a>
<a class="sourceLine" id="cb47-3" data-line-number="3">prediction &lt;-<span class="st"> </span><span class="kw">predict</span>(brmodel, toy<span class="op">$</span>test)</a>
<a class="sourceLine" id="cb47-4" data-line-number="4"></a>
<a class="sourceLine" id="cb47-5" data-line-number="5"><span class="co"># Using the test dataset and the prediction</span></a>
<a class="sourceLine" id="cb47-6" data-line-number="6">result &lt;-<span class="st"> </span><span class="kw">multilabel_evaluate</span>(toy<span class="op">$</span>test, prediction)</a>
<a class="sourceLine" id="cb47-7" data-line-number="7"><span class="kw">print</span>(<span class="kw">round</span>(result, <span class="dv">3</span>))</a></code></pre></div>
<pre><code>##                F1          accuracy average-precision               clp 
##             0.721             0.614             0.828             0.400 
##          coverage      hamming-loss         macro-AUC          macro-F1 
##             2.067             0.220             0.626             0.343 
##   macro-precision      macro-recall       margin-loss         micro-AUC 
##             0.300             0.400             1.133             0.792 
##          micro-F1   micro-precision      micro-recall               mlp 
##             0.732             0.750             0.714             0.600 
##         one-error         precision      ranking-loss            recall 
##             0.233             0.750             0.206             0.739 
##   subset-accuracy               wlp 
##             0.267             0.600</code></pre>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="co"># Build a confusion matrix</span></a>
<a class="sourceLine" id="cb49-2" data-line-number="2">confmat &lt;-<span class="st"> </span><span class="kw">multilabel_confusion_matrix</span>(toy<span class="op">$</span>test, prediction)</a>
<a class="sourceLine" id="cb49-3" data-line-number="3">result &lt;-<span class="st"> </span><span class="kw">multilabel_evaluate</span>(confmat)</a>
<a class="sourceLine" id="cb49-4" data-line-number="4"><span class="kw">print</span>(confmat)</a></code></pre></div>
<pre><code>## Multi-label Confusion Matrix
## 
## Absolute Matrix:
## -------------------------------------
##              Expected_1 Expected_0 TOTAL
## Prediction_1         45         15    60
## Predicion_0          18         72    90
## TOTAL                63         87   150
## 
## Proportinal Matrix:
## -------------------------------------
##              Expected_1 Expected_0 TOTAL
## Prediction_1       0.30       0.10   0.4
## Predicion_0        0.12       0.48   0.6
## TOTAL              0.42       0.58   1.0
## 
## Label Matrix
## -------------------------------------
##    TP FP FN TN Correct Wrong  %TP  %FP  %FN  %TN %Correct %Wrong
## y1  0  0  4 26      26     4 0.00 0.00 0.13 0.87     0.87   0.13
## y2 23  7  0  0      23     7 0.77 0.23 0.00 0.00     0.77   0.23
## y3  0  0  8 22      22     8 0.00 0.00 0.27 0.73     0.73   0.27
## y4 22  8  0  0      22     8 0.73 0.27 0.00 0.00     0.73   0.27
## y5  0  0  6 24      24     6 0.00 0.00 0.20 0.80     0.80   0.20
##    MeanRanking MeanScore
## y1        3.73      0.19
## y2        1.00      0.79
## y3        4.53      0.15
## y4        2.00      0.68
## y5        3.73      0.19</code></pre>
<p>The confusion matrix summarizes a lot of data, and can be merged. For example, using a k-fold experiment:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb51-1" data-line-number="1">kfcv &lt;-<span class="st"> </span><span class="kw">create_kfold_partition</span>(toyml, <span class="dt">k=</span><span class="dv">3</span>)</a>
<a class="sourceLine" id="cb51-2" data-line-number="2">confmats &lt;-<span class="st"> </span><span class="kw">lapply</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="cf">function</span> (k) {</a>
<a class="sourceLine" id="cb51-3" data-line-number="3">  toy &lt;-<span class="st"> </span><span class="kw">partition_fold</span>(kfcv, k)</a>
<a class="sourceLine" id="cb51-4" data-line-number="4">  model &lt;-<span class="st"> </span><span class="kw">br</span>(toy<span class="op">$</span>train, <span class="st">&quot;RF&quot;</span>)</a>
<a class="sourceLine" id="cb51-5" data-line-number="5">  <span class="kw">multilabel_confusion_matrix</span>(toy<span class="op">$</span>test, <span class="kw">predict</span>(model, toy<span class="op">$</span>test))</a>
<a class="sourceLine" id="cb51-6" data-line-number="6">})</a>
<a class="sourceLine" id="cb51-7" data-line-number="7">result &lt;-<span class="st"> </span><span class="kw">multilabel_evaluate</span>(<span class="kw">merge_mlconfmat</span>(confmats))</a></code></pre></div>
<p>Its possible choose which measures will be computed:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb52-1" data-line-number="1"><span class="co"># Example-based measures</span></a>
<a class="sourceLine" id="cb52-2" data-line-number="2">result &lt;-<span class="st"> </span><span class="kw">multilabel_evaluate</span>(confmat, <span class="st">&quot;example-based&quot;</span>)</a>
<a class="sourceLine" id="cb52-3" data-line-number="3"><span class="kw">print</span>(<span class="kw">names</span>(result))</a></code></pre></div>
<pre><code>## [1] &quot;F1&quot;              &quot;accuracy&quot;        &quot;hamming-loss&quot;    &quot;precision&quot;      
## [5] &quot;recall&quot;          &quot;subset-accuracy&quot;</code></pre>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb54-1" data-line-number="1"><span class="co"># Subset accuracy, F1 measure and hamming-loss</span></a>
<a class="sourceLine" id="cb54-2" data-line-number="2">result &lt;-<span class="st"> </span><span class="kw">multilabel_evaluate</span>(confmat, <span class="kw">c</span>(<span class="st">&quot;subset-accuracy&quot;</span>, <span class="st">&quot;F1&quot;</span>, <span class="st">&quot;hamming-loss&quot;</span>))</a>
<a class="sourceLine" id="cb54-3" data-line-number="3"><span class="kw">print</span>(<span class="kw">names</span>(result))</a></code></pre></div>
<pre><code>## [1] &quot;F1&quot;              &quot;hamming-loss&quot;    &quot;subset-accuracy&quot;</code></pre>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="co"># Ranking and label-basedd measures</span></a>
<a class="sourceLine" id="cb56-2" data-line-number="2">result &lt;-<span class="st"> </span><span class="kw">multilabel_evaluate</span>(confmat, <span class="kw">c</span>(<span class="st">&quot;label-based&quot;</span>, <span class="st">&quot;ranking&quot;</span>))</a>
<a class="sourceLine" id="cb56-3" data-line-number="3"><span class="kw">print</span>(<span class="kw">names</span>(result))</a></code></pre></div>
<pre><code>##  [1] &quot;average-precision&quot; &quot;coverage&quot;          &quot;macro-AUC&quot;        
##  [4] &quot;macro-F1&quot;          &quot;macro-precision&quot;   &quot;macro-recall&quot;     
##  [7] &quot;margin-loss&quot;       &quot;micro-AUC&quot;         &quot;micro-F1&quot;         
## [10] &quot;micro-precision&quot;   &quot;micro-recall&quot;      &quot;one-error&quot;        
## [13] &quot;ranking-loss&quot;</code></pre>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb58-1" data-line-number="1"><span class="co"># To see all the supported measures you can try</span></a>
<a class="sourceLine" id="cb58-2" data-line-number="2"><span class="kw">multilabel_measures</span>()</a></code></pre></div>
<pre><code>##  [1] &quot;F1&quot;                &quot;accuracy&quot;          &quot;all&quot;              
##  [4] &quot;average-precision&quot; &quot;bipartition&quot;       &quot;clp&quot;              
##  [7] &quot;coverage&quot;          &quot;example-based&quot;     &quot;hamming-loss&quot;     
## [10] &quot;label-based&quot;       &quot;label-problem&quot;     &quot;macro-AUC&quot;        
## [13] &quot;macro-F1&quot;          &quot;macro-based&quot;       &quot;macro-precision&quot;  
## [16] &quot;macro-recall&quot;      &quot;margin-loss&quot;       &quot;micro-AUC&quot;        
## [19] &quot;micro-F1&quot;          &quot;micro-based&quot;       &quot;micro-precision&quot;  
## [22] &quot;micro-recall&quot;      &quot;mlp&quot;               &quot;one-error&quot;        
## [25] &quot;precision&quot;         &quot;ranking&quot;           &quot;ranking-loss&quot;     
## [28] &quot;recall&quot;            &quot;subset-accuracy&quot;   &quot;wlp&quot;</code></pre>
</div>
<div id="how-to-contribute" class="section level2">
<h2>8. How to Contribute</h2>
<p>The <strong>utiml</strong> repository is available on (<a href="https://github.com/rivolli/utiml" class="uri">https://github.com/rivolli/utiml</a>). If you want to contribute with the development of this package, contact us and you will be very welcome.</p>
<p>Please, report any bugs or suggestions on CRAN mail or git hub page.</p>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>You may also be interested in <a href="https://CRAN.R-project.org/package=mldr.datasets">mldr.datasets</a><a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>Requires the <a href="https://CRAN.R-project.org/package=randomForest">randomForest</a> package.<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
